---
plugin: reconstructed
instructions:

  # Check whether that host is managed
  - action: set_fact
    name: inv__managed
    value: >-
      {{ inv__data is defined
         and inv__data.network is defined
         and inv__data.service is defined
         and inv__data.instance is defined }}
  - when: not inv__managed
    action: stop

  # Fail when the host name starts with "evil".
  - action: block
    block:
      - when: inventory_hostname.startswith( 'evil' )
        action: fail
        msg: "{{ inventory_hostname }} is obviously evil, skipping."
    rescue:
      # Do not crash on redeemably evil VMs, but still skip them.
      - when: inv__data.unredeemable is defined
        action: fail
        msg: "{{ reconstructed_error }}"
      - action: create_group
        group: reedmably_evil
      - action: add_host
        group: reedmably_evil
      - action: stop

  # Only create the managed groups if we *have* managed hosts
  - action: create_group
    group: managed
  - loop: [by_environment, by_network, by_failover_stack, by_service]
    action: block
    block:
      - action: create_group
        group: "{{ item }}"
      - action: add_child
        group: managed
        child: "{{ item }}"

  # Copy inv__data fields to separate inv__ variables
  - loop:
      - component
      - description
      - fostack
      - instance
      - network
      - service
      - subcomponent
    when: inv__data[item] is defined
    action: set_fact
    name: "inv__{{ item }}"
    value: "{{ inv__data[ item ] }}"

  # Environment variable and groups
  - action: set_fact
    name: inv__environment
    value: >-
      {{
        inv__data.environment | default(
          ( inv__instance == "prod" ) | ternary( "prod", "dev" )
        )
      }}
  - action: create_group
    group: "env_{{ inv__environment }}"
  - action: add_child
    group: by_environment
    child: "env_{{ inv__environment }}"
  - action: add_host
    group: "env_{{ inv__environment }}"

  # Failover stack group
  - action: set_var
    name: failover_group
    value: >-
      {{
        ( inv__fostack is defined )
        | ternary( "fostack_" ~ inv__fostack | default("") , "no_failover" )
      }}
  - action: create_group
    group: "{{ failover_group }}"
  - action: add_child
    group: by_failover_stack
    child: "{{ failover_group }}"
  - action: add_host
    group: "{{ failover_group }}"

  # Network group
  - action: set_var
    name: network_group
    value: "net_{{ inv__network }}"
  - action: create_group
    group: "{{ network_group }}"
  - action: add_child
    group: by_network
    child: "{{ network_group }}"
  - action: add_host
    group: "{{ network_group }}"

  # Service group
  - action: set_var
    name: service_group
    value: "svc_{{ inv__service }}"
  - action: create_group
    group: "{{ service_group }}"
  - action: add_child
    group: by_service
    child: "{{ service_group }}"

  # Component group. We add the host directly if there is no subcomponent.
  - when: inv__component is defined
    action: block
    locals:
      comp_group: "svcm_{{ inv__service }}_{{ inv__component }}"
    block:
    - action: create_group
      group: "{{ comp_group }}"
    - action: add_child
      group: "{{ service_group }}"
      child: "{{ comp_group }}"
    # Subcomponent group, or lack thereof.
    - when: inv__subcomponent is not defined
      action: add_host
      group: "{{ comp_group }}"
    - when: inv__subcomponent is defined
      action: block
      locals:
        subcomp_group: "svcm_{{ inv__service }}_{{ inv__subcomponent }}"
      block:
      - action: create_group
        group: "{{ subcomp_group }}"
      - action: add_child
        group: "{{ comp_group }}"
        child: "{{ subcomp_group }}"
      - action: add_host
        group: "{{ subcomp_group }}"
